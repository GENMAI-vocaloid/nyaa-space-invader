<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>にゃーすべーだー</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body { background:#000; color:#fff; text-align:center; margin:0; overflow:hidden; font-family:monospace; }
  canvas { background:#000; display:block; margin:0 auto; border-bottom:1px solid #111; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="600" height="420"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const STATE = { OP:'op', PLAY:'play', PAUSE:'pause', WIN:'win', GAMEOVER:'gameover' };
let state = STATE.OP;
let score = 0, totalStartTime = 0, lastKillTime = 0;

// ===== BGM（外部ファイルをギャップレスループ） =====
let audioCtx, bgmBuffer=null, bgmSource=null, musicGain=null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
async function loadBGM(url){
  ensureAudio();
  if(!musicGain){ musicGain = audioCtx.createGain(); musicGain.gain.value = 0.25; musicGain.connect(audioCtx.destination); }
  const res = await fetch(url);
  const arr = await res.arrayBuffer();
  bgmBuffer = await audioCtx.decodeAudioData(arr);
}
function startBGM(){
  if(!bgmBuffer) return;
  stopBGM();
  bgmSource = audioCtx.createBufferSource();
  bgmSource.buffer = bgmBuffer;
  bgmSource.loop = true;
  bgmSource.connect(musicGain);
  bgmSource.start();
}
function stopBGM(){
  if(bgmSource){ try{ bgmSource.stop(); }catch{} bgmSource.disconnect(); bgmSource=null; }
}

// ===== 効果音 =====
function note(freq,dur,type='square',gain=0.05){ if(!audioCtx) return; const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g).connect(audioCtx.destination); o.start(); setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.05); o.stop(audioCtx.currentTime+0.06); }, dur); }
function sfxShoot(){ note(900,60,'square',0.08); }
function sfxMeow(){ /* 猫鳴き音のコードをここに挿入 */ }
function sfxGameOver(){ if(!audioCtx) return; const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(600,audioCtx.currentTime); o.frequency.exponentialRampToValueAtTime(120,audioCtx.currentTime+0.5); g.gain.value=0.08; o.connect(g).connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.5); o.stop(audioCtx.currentTime+0.52); }

// ===== Entities =====
const player = { x: canvas.width/2-20, y: canvas.height-56, w: 40, h: 18, speed: 6 };
let bullets = [];
const CAT_TYPES=[{key:'saba',base:'#9aa3ab'},{key:'chatora',base:'#f39a3d'},{key:'bicolor',base:'#ffffff'},{key:'tortoise',base:'#7a4a2a'},{key:'mike',base:'#fff0e6'},{key:'kuro',base:'#222'},{key:'shiro',base:'#f7f7f7'},{key:'russian',base:'#7f8fa6'}];
const CAT_W=34, CAT_H=26; let cats=[], catDir=1, catStepTimer=0;
function initCats(){ cats=[]; const top=36; for(let r=0;r<8;r++){ for(let c=0;c<8;c++){ cats.push({ x:38+c*66, y:top+r*34, type:CAT_TYPES[r].key, alive:true }); } } }
initCats();

// ===== Input =====
const keys={};
addEventListener('keydown', e=>{
  keys[e.code]=true;
  if((state===STATE.WIN||state===STATE.GAMEOVER)&&e.code==='KeyR'){ startGame(); }
  if(state===STATE.OP && e.code==='Space'){
    ensureAudio(); audioCtx.resume&&audioCtx.resume();
    if(!bgmBuffer) loadBGM('bgm.mp3').then(startGame);
    else startGame();
  }
  if(e.code==='Enter' && state===STATE.PLAY){ state=STATE.PAUSE; stopBGM(); }
  else if(e.code==='Enter' && state===STATE.PAUSE){ state=STATE.PLAY; startBGM(); }
});
addEventListener('keyup', e=> keys[e.code]=false);
canvas.addEventListener('click', ()=>{
  if(state===STATE.OP||state===STATE.WIN||state===STATE.GAMEOVER){
    ensureAudio(); audioCtx&&audioCtx.resume&&audioCtx.resume();
    if(!bgmBuffer) loadBGM('bgm.mp3').then(startGame);
    else startGame();
  }
});

// ===== Render =====
function drawPlayer(){ if(state!==STATE.PLAY) return; ctx.fillStyle='#aaff44'; ctx.fillRect(player.x,player.y,player.w,player.h); ctx.fillRect(player.x+player.w*0.35,player.y-player.h*0.4,player.w*0.3,player.h*0.4); }
function drawFishBullet(b){ ctx.save(); ctx.translate(b.x,b.y); ctx.beginPath(); ctx.ellipse(0,0,8,4,0,0,Math.PI*2); ctx.fillStyle='#7fd7ff'; ctx.fill(); ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(-14,-4); ctx.lineTo(-14,4); ctx.closePath(); ctx.fill(); ctx.fillStyle='#004a66'; ctx.beginPath(); ctx.arc(4,-1,1.5,0,Math.PI*2); ctx.fill(); ctx.restore(); }
function drawCatSprite(cat){ const {x,y,type}=cat; ctx.save(); ctx.translate(x,y); const base=CAT_TYPES.find(t=>t.key===type).base; ctx.fillStyle=base; ctx.fillRect(0,6,CAT_W,CAT_H-6); ctx.beginPath(); ctx.moveTo(4,6); ctx.lineTo(12,-2); ctx.lineTo(16,6); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(CAT_W-4,6); ctx.lineTo(CAT_W-12,-2); ctx.lineTo(CAT_W-16,6); ctx.closePath(); ctx.fill(); ctx.fillStyle=(type==='kuro')?'#eef':'#222'; ctx.fillRect(10,14,4,4); ctx.fillRect(CAT_W-14,14,4,4); ctx.strokeStyle=(type==='kuro')?'#bbb':'#ddd'; ctx.lineWidth=1; for(const dy of [16,19]){ ctx.beginPath(); ctx.moveTo(6,dy); ctx.lineTo(0,dy-1); ctx.stroke(); ctx.beginPath(); ctx.moveTo(CAT_W-6,dy); ctx.lineTo(CAT_W,dy-1); ctx.stroke(); } ctx.restore(); }
function drawCats(){ if(state!==STATE.PLAY) return; cats.forEach(c=>{ if(c.alive) drawCatSprite(c); }); }
function drawBullets(){ if(state!==STATE.PLAY) return; bullets.forEach(b=> drawFishBullet(b)); }

function drawUI(){ ctx.fillStyle='#fff'; ctx.textAlign='center'; if(state===STATE.OP){ ctx.save(); ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=6; ctx.shadowOffsetY=2; ctx.font='bold 34px monospace'; ctx.fillText('にゃーすべーだー', canvas.width/2, canvas.height/2 - 20); ctx.restore(); ctx.font='18px monospace'; ctx.fillText('クリック or Space でスタート', canvas.width/2, canvas.height/2 + 16); ctx.font='14px monospace'; ctx.fillText('← → 移動 / Space 魚 / Enter ポーズ', canvas.width/2, canvas.height/2 + 38); } else if(state===STATE.WIN){ ctx.font='bold 26px monospace'; ctx.fillText('猫ちゃん大満足！', canvas.width/2, 160); ctx.font='18px monospace'; ctx.fillText(`合計スコア: ${score}`, canvas.width/2, 190); ctx.fillText('クリック / R でリスタート', canvas.width/2, 214); } else if(state===STATE.GAMEOVER){ ctx.font='bold 26px monospace'; ctx.fillText('ゲームオーバー', canvas.width/2, 160); ctx.font='18px monospace'; ctx.fillText(`スコア: ${score}`, canvas.width/2, 190); ctx.fillText('クリック / R でリスタート', canvas.width/2, 214); } else if(state===STATE.PAUSE){ ctx.font='bold 26px monospace'; ctx.fillText('PAUSE', canvas.width/2, 180); ctx.font='16px monospace'; ctx.fillText('Enterで再開', canvas.width/2, 206); ctx.textAlign='left'; ctx.font='14px monospace'; ctx.fillText(`SCORE: ${score}`,16,20); } else if(state===STATE.PLAY){ ctx.textAlign='left'; ctx.font='14px monospace'; ctx.fillText(`SCORE: ${score}`,16,20); } ctx.textAlign='left'; }

// ===== Update =====
let shotCooldown=0; function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){ return !(ax+aw<bx || bx+bw<ax || ay+ah<by || by+bh<ay); }
function update(dt){ if(state!==STATE.PLAY) return; if(keys['ArrowLeft']) player.x-=player.speed; if(keys['ArrowRight']) player.x+=player.speed; player.x=Math.max(10,Math.min(canvas.width-player.w-10,player.x)); shotCooldown-=dt; if(keys['Space']&&shotCooldown<=0){ bullets.push({x:player.x+player.w/2+10,y:player.y-12,vy:-360,dead:false}); shotCooldown=150; sfxShoot(); } bullets.forEach(b=>{ b.y+=b.vy*(dt/1000); }); bullets=bullets.filter(b=>!b.dead&&b.y>-20); catStepTimer+=dt; if(catStepTimer>150){ catStepTimer=0; let edgeHit=false; cats.forEach(c=>{ if(!c.alive) return; c.x+=3*catDir; if(c.x<10||c.x+CAT_W>canvas.width-10) edgeHit=true; }); if(edgeHit){ catDir*=-1; cats.forEach(c=>{ if(c.alive) c.y+=10; }); } } bullets.forEach(b=>{ if(b.dead) return; for(const c of cats){ if(!c.alive) continue; if(b.x>c.x-10&&b.x<c.x+CAT_W+2&&b.y>c.y-6&&b.y<c.y+CAT_H){ c.alive=false; b.dead=true; sfxMeow(); const now=performance.now(); const delta=lastKillTime?(now-lastKillTime):999; lastKillTime=now; const bonus=Math.max(10,Math.min(300,Math.floor(350-delta/2))); score+=bonus; break; } } }); for(const c of cats){ if(!c.alive) continue; if(rectsOverlap(player.x,player.y,player.w,player.h,c.x,c.y,CAT_W,CAT_H)){ state=STATE.GAMEOVER; stopBGM(); sfxGameOver(); break; } } if(cats.every(c=>!c.alive)){ const total=performance.now()-totalStartTime; score+=Math.max(100,Math.floor(20000/Math.max(1,total/1000))); state=STATE.WIN; stopBGM(); } }

function startGame(){ state=STATE.PLAY; score=0; lastKillTime=0; totalStartTime=performance.now(); bullets=[]; player.x=canvas.width/2-20; catDir=1; catStepTimer=0; initCats(); startBGM(); }

// ===== Loop =====
let prev=performance.now();
function loop(now){ const dt=now-prev; prev=now; ctx.clearRect(0,0,canvas.width,canvas.height); if(state===STATE.PLAY){ drawCats(); drawBullets(); drawPlayer(); } drawUI(); update(dt); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>
